### **B. Remote System Administration (15 minutes)**

#### **Advanced Remote System Management**

```bash
#!/bin/bash
# Advanced Remote System Administration Toolkit

echo "üë®‚Äçüíº ADVANCED REMOTE SYSTEM ADMINISTRATION"
echo "=========================================="

# Create administration directory structure
mkdir -p ~/workshop_admin/{scripts,reports,maintenance,emergency}

# Function to create system health report
generate_system_report() {
    local server=$1
    local report_file="~/workshop_admin/reports/system_report_${server}_$(date +%Y%m%d_%H%M%S).txt"
    
    echo "üìä GENERATING SYSTEM REPORT FOR $server"
    echo "======================================="
    
    # Create comprehensive system report
    cat > "$report_file" << EOF
WORKSHOP SYSTEM HEALTH REPORT
=============================
Server: $server
Generated: $(date)
Administrator: $(whoami)

SYSTEM INFORMATION:
EOF

    # Gather system information
    ssh "$server" "echo 'Hostname: \$(hostname)'" >> "$report_file"
    ssh "$server" "echo 'OS: \$(lsb_release -d 2>/dev/null | cut -f2 || uname -s)'" >> "$report_file"
    ssh "$server" "echo 'Kernel: \$(uname -r)'" >> "$report_file"
    ssh "$server" "echo 'Architecture: \$(uname -m)'" >> "$report_file"
    ssh "$server" "echo 'Uptime: \$(uptime -p)'" >> "$report_file"
    
    echo "" >> "$report_file"
    echo "RESOURCE UTILIZATION:" >> "$report_file"
    ssh "$server" "echo 'CPU Usage: \$(top -bn1 | grep \"Cpu(s)\" | awk \"{print \\\$2}\")'" >> "$report_file"
    ssh "$server" "free -h" >> "$report_file"
    ssh "$server" "df -h" >> "$report_file"
    
    echo "" >> "$report_file"
    echo "NETWORK INFORMATION:" >> "$report_file"
    ssh "$server" "ip addr show | grep -E '^[0-9]|inet '" >> "$report_file"
    
    echo "" >> "$report_file"
    echo "RUNNING PROCESSES (Top 10):" >> "$report_file"
    ssh "$server" "ps aux --sort=-%cpu | head -11" >> "$report_file"
    
    echo "" >> "$report_file"
    echo "SYSTEM SERVICES STATUS:" >> "$report_file"
    ssh "$server" "systemctl list-units --type=service --state=running --no-pager" >> "$report_file"
    
    echo "" >> "$report_file"
    echo "DISK USAGE BY DIRECTORY:" >> "$report_file"
    ssh "$server" "du -sh /var/log /tmp /home 2>/dev/null" >> "$report_file"
    
    echo "" >> "$report_file"
    echo "RECENT SYSTEM ERRORS:" >> "$report_file"
    ssh "$server" "journalctl --since '1 day ago' -p err --no-pager | tail -10" >> "$report_file"
    
    echo "‚úÖ System report generated: $report_file"
    echo "üìÑ Report saved locally and can be viewed with: less $report_file"
}

# Function for remote maintenance operations
perform_remote_maintenance() {
    local server=$1
    
    echo "üîß REMOTE MAINTENANCE FOR $server"
    echo "================================="
    
    echo "üìã Maintenance checklist:"
    echo "1. Update system packages"
    echo "2. Clean temporary files"
    echo "3. Check disk space"
    echo "4. Review system logs"
    echo "5. Verify service status"
    echo ""
    
    read -p "Proceed with maintenance? (y/n): " proceed
    if [ "$proceed" != "y" ]; then
        echo "‚ùå Maintenance cancelled"
        return
    fi
    
    # Log maintenance start
    maintenance_log="~/workshop_admin/maintenance/maintenance_${server}_$(date +%Y%m%d_%H%M%S).log"
    echo "üîß Starting maintenance for $server at $(date)" > "$maintenance_log"
    
    # 1. Update package lists
    echo "üì¶ Updating package lists..."
    if ssh "$server" "sudo apt update >/dev/null 2>&1"; then
        echo "‚úÖ Package lists updated" | tee -a "$maintenance_log"
    else
        echo "‚ùå Failed to update package lists" | tee -a "$maintenance_log"
    fi
    
    # 2. Clean temporary files
    echo "üßπ Cleaning temporary files..."
    temp_cleaned=$(ssh "$server" "find /tmp -type f -atime +1 2>/dev/null | wc -l")
    ssh "$server" "find /tmp -type f -atime +1 -delete 2>/dev/null"
    echo "‚úÖ Cleaned $temp_cleaned temporary files" | tee -a "$maintenance_log"
    
    # 3. Check available updates
    echo "üîÑ Checking for available updates..."
    updates_available=$(ssh "$server" "apt list --upgradable 2>/dev/null | grep -c upgradable" || echo "0")
    echo "üìä $updates_available updates available" | tee -a "$maintenance_log"
    
    # 4. Check disk space
    echo "üíΩ Checking disk space..."
    ssh "$server" "df -h | grep -E '9[0-9]%|100%'" | while read line; do
        echo "‚ö†Ô∏è High disk usage: $line" | tee -a "$maintenance_log"
    done
    
    # 5. Check system load
    echo "‚öñÔ∏è Checking system performance..."
    load_avg=$(ssh "$server" "uptime | awk -F'load average:' '{print \$2}'")
    echo "üìä Current load average:$load_avg" | tee -a "$maintenance_log"
    
    echo "üéâ Maintenance completed for $server"
    echo "üìÑ Maintenance log: $maintenance_log"
}

# Function for emergency system response
emergency_response() {
    local server=$1
    
    echo "üö® EMERGENCY RESPONSE FOR $server"
    echo "================================="
    
    # Quick system stabilization
    echo "ü©∫ Performing emergency system check..."
    
    # Check if server is responsive
    if ! ssh -o ConnectTimeout=10 "$server" 'exit' 2>/dev/null; then
        echo "‚ùå CRITICAL: Cannot connect to $server"
        echo "üîß Troubleshooting steps:"
        echo "   1. Check network connectivity: ping $server"
        echo "   2. Verify SSH service is running"
        echo "   3. Check firewall settings"
        echo "   4. Contact system administrator"
        return 1
    fi
    
    echo "‚úÖ Server is responsive"
    
    # Check critical services
    echo "üîç Checking critical services..."
    critical_services=("ssh" "networking")
    
    for service in "${critical_services[@]}"; do
        if ssh "$server" "systemctl is-active $service >/dev/null 2>&1"; then
            echo "‚úÖ $service: Running"
        else
            echo "‚ùå $service: FAILED - Attempting restart..."
            ssh "$server" "sudo systemctl restart $service"
            
            if ssh "$server" "systemctl is-active $service >/dev/null 2>&1"; then
                echo "‚úÖ $service: Restarted successfully"
            else
                echo "üö® $service: RESTART FAILED - Manual intervention required"
            fi
        fi
    done
    
    # Check system resources
    echo "üìä Checking system resources..."
    
    # Memory check
    memory_usage=$(ssh "$server" "free | grep Mem | awk '{printf \"%.0f\", \$3/\$2 * 100}'")
    if [ "$memory_usage" -gt 90 ]; then
        echo "üö® CRITICAL: Memory usage is ${memory_usage}%"
        echo "üîß Emergency action: Clearing system caches..."
        ssh "$server" "sync && echo 3 | sudo tee /proc/sys/vm/drop_caches >/dev/null"
    else
        echo "‚úÖ Memory usage: ${memory_usage}%"
    fi
    
    # Disk space check
    disk_usage=$(ssh "$server" "df / | tail -1 | awk '{print \$5}' | sed 's/%//'")
    if [ "$disk_usage" -gt 95 ]; then
        echo "üö® CRITICAL: Disk usage is ${disk_usage}%"
        echo "üîß Emergency action: Cleaning temporary files..."
        ssh "$server" "find /tmp -type f -atime +1 -delete 2>/dev/null"
        ssh "$server" "journalctl --vacuum-time=7d >/dev/null 2>&1"
    else
        echo "‚úÖ Disk usage: ${disk_usage}%"
    fi
    
    # System load check
    load_avg=$(ssh "$server" "uptime | awk '{print \$(NF-2)}' | sed 's/,//'")
    cpu_cores=$(ssh "$server" "nproc")
    
    echo "üìä Load average: $load_avg (CPU cores: $cpu_cores)"
    
    echo "üéØ Emergency response completed for $server"
}

# Function for batch operations across multiple servers
batch_operations() {
    local servers=("oracle3dove")
    local operation=$1
    
    echo "üîÑ BATCH OPERATION: $operation"
    echo "=============================="
    
    for server in "${servers[@]}"; do
        echo ""
        echo "üè≠ Processing $server..."
        echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
        
        case $operation in
            "status")
                ssh "$server" "echo '‚úÖ $server is online'; uptime"
                ;;
            "update")
                echo "üì¶ Updating $server..."
                ssh "$server" "sudo apt update && sudo apt upgrade -y"
                ;;
            "cleanup")
                echo "üßπ Cleaning $server..."
                ssh "$server" "find /tmp -type f -atime +1 -delete 2>/dev/null; apt autoremove -y >/dev/null 2>&1"
                ;;
            "backup")
                echo "üíæ Creating backup on $server..."
                ssh "$server" "tar -czf /tmp/system_backup_\$(date +%Y%m%d_%H%M%S).tar.gz /etc/passwd /etc/group /etc/hostname 2>/dev/null"
                ;;
            *)
                echo "‚ùå Unknown operation: $operation"
                ;;
        esac
    done
    
    echo ""
    echo "üéâ Batch operation '$operation' completed on all servers"
}

# Main administration menu
admin_menu() {
    echo ""
    echo "üë®‚Äçüíº REMOTE ADMINISTRATION MENU"
    echo "=============================="
    echo "1) Generate system health report"
    echo "2) Perform remote maintenance"
    echo "3) Emergency system response"
    echo "4) Batch operations"
    echo "5) View administration logs"
    echo "6) Exit"
    echo ""
}

# Main program loop
while true; do
    admin_menu
    read -p "Choose operation (1-6): " choice
    
    case $choice in
        1)
            read -p "Enter server name (e.g., oracle3dove): " server
            generate_system_report "$server"
            ;;
        2)
            read -p "Enter server name: " server
            perform_remote_maintenance "$server"
            ;;
        3)
            read -p "Enter server name for emergency response: " server
            emergency_response "$server"
            ;;
        4)
            echo "Available batch operations:"
            echo "  status  - Check status of all servers"
            echo "  update  - Update all servers"
            echo "  cleanup - Clean temporary files on all servers"
            echo "  backup  - Create system backups on all servers"
            read -p "Enter operation: " operation
            batch_operations "$operation"
            ;;
        5)
            echo "üìã Recent administration activity:"
            find ~/workshop_admin -name "*.log" -exec tail -5 {} \; 2>/dev/null || echo "No logs found"
            ;;
        6)
            echo "üëã Exiting Remote Administration"
            break
            ;;
        *)
            echo "‚ùå Invalid choice"
            ;;
    esac
    
    read -p "Press Enter to continue..."
done
```

---

## **Part 4: Troubleshooting Remote Connections (20 minutes)**

### **A. Connection Problem Diagnosis (10 minutes)**

#### **SSH Connection Troubleshooter**

```bash
#!/bin/bash
# SSH Connection Troubleshooting Tool

echo "üîß SSH CONNECTION TROUBLESHOOTER"
echo "==============================="

# Function to test basic connectivity
test_connectivity() {
    local host=$1
    local port=${2:-22}
    
    echo "üåê Testing basic connectivity to $host:$port..."
    
    # Test ping
    if ping -c 3 -W 3 "$host" >/dev/null 2>&1; then
        echo "‚úÖ Ping successful"
        ping_stats=$(ping -c 3 "$host" | tail -1)
        echo "üìä $ping_stats"
    else
        echo "‚ùå Ping failed - network connectivity issues"
        return 1
    fi
    
    # Test port connectivity
    echo "üîå Testing SSH port accessibility..."
    if timeout 10 bash -c "echo >/dev/tcp/$host/$port" 2>/dev/null; then
        echo "‚úÖ Port $port is accessible"
    else
        echo "‚ùå Port $port is not accessible"
        echo "üîß Possible causes:"
        echo "   ‚Ä¢ SSH service not running on remote server"
        echo "   ‚Ä¢ Firewall blocking connections"
        echo "   ‚Ä¢ Wrong port number"
        return 1
    fi
    
    return 0
}

# Function to test SSH authentication
test_ssh_authentication() {
    local connection=$1
    
    echo ""
    echo "üîê Testing SSH authentication for $connection..."
    
    # Test SSH connection with timeout
    if timeout 15 ssh -o ConnectTimeout=10 -o BatchMode=yes "$connection" 'echo "SSH authentication successful"' 2>/dev/null; then
        echo "‚úÖ SSH authentication successful"
        
        # Get remote system info
        echo "üìä Remote system information:"
        ssh "$connection" 'echo "  Hostname: $(hostname)"'
        ssh "$connection" 'echo "  User: $(whoami)"'
        ssh "$connection" 'echo "  Home: $(pwd)"'
        return 0
    else
        echo "‚ùå SSH authentication failed"
        
        # Detailed diagnosis
        echo "üîç Running detailed diagnosis..."
        ssh -v -o ConnectTimeout=10 "$connection" 'exit' 2>/tmp/ssh_debug.log
        
        echo "üîß Common authentication issues:"
        if grep -q "Permission denied" /tmp/ssh_debug.log; then
            echo "   ‚Ä¢ Wrong username or password"
            echo "   ‚Ä¢ SSH key not properly deployed"
            echo "   ‚Ä¢ SSH key permissions incorrect"
        fi
        
        if grep -q "Connection refused" /tmp/ssh_debug.log; then
            echo "   ‚Ä¢ SSH service not running"
            echo "   ‚Ä¢ Wrong port number"
        fi
        
        if grep -q "Host key verification failed" /tmp/ssh_debug.log; then
            echo "   ‚Ä¢ Host key has changed (possible security risk)"
            echo "   ‚Ä¢ Run: ssh-keygen -R $connection"
        fi
        
        return 1
    fi
}

# Function to test SSH configuration
test_ssh_config() {
    echo ""
    echo "‚öôÔ∏è Testing SSH configuration..."
    
    # Check if SSH config exists
    if [ -f ~/.ssh/config ]; then
        echo "‚úÖ SSH config file exists"
        
        # Show relevant configuration
        echo "üìã Current SSH configuration:"
        grep -A 10 "Host oracle3dove\|Host \*" ~/.ssh/config 2>/dev/null | head -15
    else
        echo "‚ö†Ô∏è No SSH config file found"
        echo "üí° Consider creating ~/.ssh/config for easier management"
    fi
    
    # Check SSH keys
    echo ""
    echo "üîë SSH key status:"
    if [ -f ~/.ssh/id_rsa ]; then
        echo "‚úÖ Private key exists: ~/.ssh/id_rsa"
        key_info=$(ssh-keygen -lf ~/.ssh/id_rsa 2>/dev/null)
        echo "üìä Key info: $key_info"
    else
        echo "‚ùå No private key found"
        echo "üí° Generate with: ssh-keygen -t rsa -b 4096"
    fi
    
    if [ -f ~/.ssh/id_rsa.pub ]; then
        echo "‚úÖ Public key exists: ~/.ssh/id_rsa.pub"
    else
        echo "‚ùå No public key found"
    fi
    
    # Check SSH agent
    if ssh-add -l >/dev/null 2>&1; then
        echo "‚úÖ SSH agent is running with loaded keys"
        ssh-add -l
    else
        echo "‚ö†Ô∏è SSH agent not running or no keys loaded"
        echo "üí° Start with: eval \$(ssh-agent -s) && ssh-add"
    fi
}

# Function to fix common SSH issues
fix_ssh_issues() {
    echo ""
    echo "üîß SSH ISSUE REPAIR ASSISTANT"
    echo "============================="
    
    echo "üéØ Available fixes:"
    echo "1) Fix SSH key permissions"
    echo "2) Regenerate SSH keys"
    echo "3) Reset known hosts"
    echo "4) Restart SSH agent"
    echo "5) Create SSH config"
    echo "6) Deploy keys to server"
    echo ""
    
    read -p "Choose fix (1-6): " fix_choice
    
    case $fix_choice in
        1)
            echo "üîß Fixing SSH key permissions..."
            chmod 700 ~/.ssh
            chmod 600 ~/.ssh/id_rsa* 2>/dev/null
            chmod 600 ~/.ssh/config 2>/dev/null
            chmod 644 ~/.ssh/*.pub 2>/dev/null
            echo "‚úÖ SSH permissions fixed"
            ;;
        2)
            echo "üîß Regenerating SSH keys..."
            read -p "This will overwrite existing keys. Continue? (y/n): " confirm
            if [ "$confirm" = "y" ]; then
                ssh-keygen -t rsa -b 4096 -f ~/.ssh/id_rsa -N ""
                echo "‚úÖ New SSH keys generated"
            fi
            ;;
        3)
            echo "üîß Resetting known hosts..."
            read -p "Enter hostname to remove: " hostname
            ssh-keygen -R "$hostname"
            echo "‚úÖ Host removed from known hosts"
            ;;
        4)
            echo "üîß Restarting SSH agent..."
            killall ssh-agent 2>/dev/null
            eval $(ssh-agent -s)
            ssh-add ~/.ssh/id_rsa 2>/dev/null
            echo "‚úÖ SSH agent restarted"
            ;;
        5)
            echo "üîß Creating basic SSH config..."
            mkdir -p ~/.ssh
            cat > ~/.ssh/config << 'EOF'
Host oracle3dove
    HostName 79.72.72.205
    User champion
    Port 22
    IdentityFile ~/.ssh/id_rsa
    ServerAliveInterval 60
EOF
            chmod 600 ~/.ssh/config
            echo "‚úÖ Basic SSH config created"
            ;;
        6)
            echo "üîß Deploying keys to server..."
            read -p "Enter connection (e.g., champion@79.72.72.205): " server
            ssh-copy-id "$server"
            echo "‚úÖ Keys deployed to server"
            ;;
        *)
            echo "‚ùå Invalid choice"
            ;;
    esac
}

# Main troubleshooting workflow
main_troubleshooting() {
    local target_host="79.72.72.205"
    local target_connection="oracle3dove"
    
    echo "üéØ Starting SSH troubleshooting for $target_connection..."
    echo ""
    
    # Step 1: Test basic connectivity
    if ! test_connectivity "$target_host"; then
        echo "üö® Basic connectivity failed - check network and server status"
        return 1
    fi
    
    # Step 2: Test SSH authentication
    if ! test_ssh_authentication "$target_connection"; then
        echo "üö® SSH authentication failed"
        
        # Step 3: Analyze SSH configuration
        test_ssh_config
        
        # Step 4: Offer fixes
        echo ""
        read -p "Would you like to try fixing SSH issues? (y/n): " fix_prompt
        if [ "$fix_prompt" = "y" ]; then
            fix_ssh_issues
        fi
        
        # Step 5: Retest after fixes
        echo ""
        echo "üîÑ Retesting connection after fixes..."
        test_ssh_authentication "$target_connection"
    else
        echo "üéâ SSH connection is working properly!"
    fi
}

# Run main troubleshooting
main_troubleshooting

echo ""
echo "üìã TROUBLESHOOTING SUMMARY"
echo "========================="
echo "‚úÖ SSH troubleshooting completed"
echo "üìÑ Debug logs saved to: /tmp/ssh_debug.log"
echo ""
echo "üîß Additional troubleshooting commands:"
echo "   ssh -v oracle3dove           # Verbose connection test"
echo "   ssh-keygen -R hostname       # Remove host from known_hosts"
echo "   ssh-copy-id user@host        # Deploy SSH keys"
echo "   chmod 600 ~/.ssh/id_rsa     # Fix key permissions"
```

### **B. Performance Optimization (10 minutes)**

#### **SSH Performance Optimizer**

```bash
#!/bin/bash
# SSH Connection Performance Optimizer

echo "‚ö° SSH PERFORMANCE OPTIMIZER"
echo "=========================="

# Function to test current connection performance
test_connection_performance() {
    local connection=$1
    
    echo "üìä Testing connection performance to $connection..."
    
    # Test 1: Command execution speed
    echo "üèÉ Testing command execution speed..."
    local start_time=$(date +%s.%N)
    ssh "$connection" 'echo "Speed test"' >/dev/null 2>&1
    local end_time=$(date +%s.%N)
    local execution_time=$(echo "$end_time - $start_time" | bc 2>/dev/null || echo "1.0")
    
    echo "üìà Command execution time: ${execution_time}s"
    
    if (( $(echo "$execution_time < 2.0" | bc -l 2>/dev/null || echo "1") )); then
        echo "‚úÖ Command execution speed: Good"
    else
        echo "‚ö†Ô∏è Command execution speed: Slow"
    fi
    
    # Test 2: File transfer speed
    echo ""
    echo "üìÅ Testing file transfer speed..."
    echo "test data for speed test" > /tmp/speed_test_file.txt
    
    local start_time=$(date +%s.%N)
    scp /tmp/speed_test_file.txt "$connection:/tmp/" >/dev/null 2>&1
    local end_time=$(date +%s.%N)
    local transfer_time=$(echo "$end_time - $start_time" | bc 2>/dev/null || echo "1.0")
    
    echo "üìà Small file transfer time: ${transfer_time}s"
    
    if (( $(echo "$transfer_time < 3.0" | bc -l 2>/dev/null || echo "1") )); then
        echo "‚úÖ File transfer speed: Good"
    else
        echo "‚ö†Ô∏è File transfer speed: Slow"
    fi
    
    # Cleanup
    rm -f /tmp/speed_test_file.txt
    ssh "$connection" 'rm -f /tmp/speed_test_file.txt' 2>/dev/null
    
    # Test 3: Compression efficiency
    echo ""
    echo "üóúÔ∏è Testing connection compression..."
    
    # Create larger test file
    dd if=/dev/zero of=/tmp/large_test_file.txt bs=1024 count=100 >/dev/null 2>&1
    
    # Test without compression
    local start_time=$(date +%s.%N)
    scp -o Compression=no /tmp/large_test_file.txt "$connection:/tmp/large_test_no_compression.txt" >/dev/null 2>&1
    local end_time=$(date +%s.%N)
    local no_compression_time=$(echo "$end_time - $start_time" | bc 2>/dev/null || echo "5.0")
    
    # Test with compression
    local start_time=$(date +%s.%N)
    scp -o Compression=yes /tmp/large_test_file.txt "$connection:/tmp/large_test_with_compression.txt" >/dev/null 2>&1
    local end_time=$(date +%s.%N)
    local compression_time=$(echo "$end_time - $start_time" | bc 2>/dev/null || echo "5.0")
    
    echo "üìä Transfer without compression: ${no_compression_time}s"
    echo "üìä Transfer with compression: ${compression_time}s"
    
    if (( $(echo "$compression_time < $no_compression_time" | bc -l 2>/dev/null || echo "0") )); then
        echo "‚úÖ Compression improves performance"
    else
        echo "‚ö†Ô∏è Compression may not help with this connection"
    fi
    
    # Cleanup
    rm -f /tmp/large_test_file.txt
    ssh "$connection" 'rm -f /tmp/large_test_*.txt' 2>/dev/null
}

# Function to optimize SSH configuration
optimize_ssh_config() {
    echo ""
    echo "‚öôÔ∏è OPTIMIZING SSH CONFIGURATION"
    echo "==============================="
    
    # Backup current config
    if [ -f ~/.ssh/config ]; then
        cp ~/.ssh/config ~/.ssh/config.backup.$(date +%Y%m%d_%H%M%S)
        echo "üíæ Current config backed up"
    fi
    
    # Create optimized SSH config
    cat > ~/.ssh/config << 'EOF'
# Optimized SSH Configuration for Workshop Empire
# ==============================================

# Global optimizations
Host *
    # Connection optimizations
    TCPKeepAlive yes
    ServerAliveInterval 60
    ServerAliveCountMax 3
    
    # Performance optimizations
    Compression yes
    CompressionLevel 6
    
    # Security optimizations
    IdentitiesOnly yes
    AddKeysToAgent yes
    
    # Connection multiplexing (reuse connections)
    ControlMaster auto
    ControlPath ~/.ssh/sockets/%r@%h-%p
    ControlPersist 600
    
    # Faster authentication
    GSSAPIAuthentication no
    UseDNS no

# Primary Workshop Server
Host oracle3dove workshop-main primary
    HostName 79.72.72.205
    User champion
    Port 22
    IdentityFile ~/.ssh/id_rsa
    
    # Performance tuning for this server
    Cipher aes128-ctr
    MACs hmac-sha2-256
    
    # Port forwarding for web services
    LocalForward 8080 localhost:80
    
    # Specific optimizations
    IPQoS lowdelay throughput

# Development environment with proxy
Host dev-workshop
    HostName 192.168.1.100
    User developer
    Port 22
    ProxyJump oracle3dove
    IdentityFile ~/.ssh/id_rsa
    
# Production with enhanced security
Host prod-workshop
    HostName 10.0.0.50
    User admin
    Port 2222
    IdentityFile ~/.ssh/id_rsa_prod
    StrictHostKeyChecking yes
    
# Emergency access configuration
Host emergency
    HostName 79.72.72.205
    User champion
    Port 22
    IdentityFile ~/.ssh/id_rsa_emergency
    ConnectTimeout 10
    ConnectionAttempts 3
EOF

    # Create socket directory for connection multiplexing
    mkdir -p ~/.ssh/sockets
    chmod 700 ~/.ssh/sockets
    
    # Set proper permissions
    chmod 600 ~/.ssh/config
    
    echo "‚úÖ SSH configuration optimized!"
    echo ""
    echo "üéØ Optimizations applied:"
    echo "   ‚Ä¢ Connection multiplexing enabled"
    echo "   ‚Ä¢ Compression optimized"  
    echo "   ‚Ä¢ Keep-alive configured"
    echo "   ‚Ä¢ Fast ciphers selected"
    echo "   ‚Ä¢ Authentication streamlined"
}

# Function to optimize SSH keys
optimize_ssh_keys() {
    echo ""
    echo "üîë SSH KEY OPTIMIZATION"
    echo "======================"
    
    # Check current key strength
    if [ -f ~/.ssh/id_rsa ]; then
        key_bits=$(ssh-keygen -lf ~/.ssh/id_rsa | awk '{print $1}')
        echo "üìä Current key strength: $key_bits bits"
        
        if [ "$key_bits" -lt 2048 ]; then
            echo "‚ö†Ô∏è Key strength is below recommended 2048 bits"
            read -p "Generate new 4096-bit key? (y/n): " generate_new
            
            if [ "$generate_new" = "y" ]; then
                # Backup old key
                mv ~/.ssh/id_rsa ~/.ssh/id_rsa.old
                mv ~/.ssh/id_rsa.pub ~/.ssh/id_rsa.pub.old
                
                # Generate new strong key
                ssh-keygen -t rsa -b 4096 -C "$(whoami)@$(hostname)-optimized" -f ~/.ssh/id_rsa -N ""
                echo "‚úÖ New 4096-bit key generated"
                
                # Deploy to servers
                read -p "Deploy new key to oracle3dove? (y/n): " deploy_key
                if [ "$deploy_key" = "y" ]; then
                    ssh-copy-id -i ~/.ssh/id_rsa.pub oracle3dove
                    echo "‚úÖ New key deployed"
                fi
            fi
        else
            echo "‚úÖ Key strength is good"
        fi
    else
        echo "‚ùå No SSH key found"
        read -p "Generate optimized 4096-bit key? (y/n): " create_key
        
        if [ "$create_key" = "y" ]; then
            ssh-keygen -t rsa -b 4096 -C "$(whoami)@$(hostname)-optimized" -f ~/.ssh/id_rsa -N ""
            echo "‚úÖ Optimized SSH key created"
        fi
    fi
    
    # Optimize SSH agent
    echo ""
    echo "üîÑ Optimizing SSH agent..."
    
    # Kill existing agents
    pkill -u $(whoami) ssh-agent 2>/dev/null
    
    # Start optimized SSH agent
    eval $(ssh-agent -s)
    
    # Add keys with timeout
    ssh-add -t 3600 ~/.ssh/id_rsa 2>/dev/null  # 1 hour timeout
    
    echo "‚úÖ SSH agent optimized with key timeout"
}

# Function to test and compare performance
performance_comparison() {
    local connection=$1
    
    echo ""
    echo "üìä PERFORMANCE COMPARISON"
    echo "========================"
    
    echo "üîÑ Testing with current settings..."
    test_connection_performance "$connection"
    
    echo ""
    echo "‚ö° Applying optimizations..."
    optimize_ssh_config
    
    echo ""
    echo "üîÑ Testing with optimized settings..."
    test_connection_performance "$connection"
    
    echo ""
    echo "üéâ Performance optimization completed!"
}

# Function to create connection monitoring script
create_connection_monitor() {
    cat > ~/workshop_admin/scripts/connection_monitor.sh << 'EOF'
#!/bin/bash
# SSH Connection Performance Monitor

MONITOR_LOG="$HOME/workshop_admin/logs/connection_performance.log"
mkdir -p "$(dirname "$MONITOR_LOG")"

# Function to test connection and log performance
test_and_log() {
    local connection=$1
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # Test command execution time
    local start_time=$(date +%s.%N)
    if ssh -o ConnectTimeout=10 "$connection" 'echo "test"' >/dev/null 2>&1; then
        local end_time=$(date +%s.%N)
        local response_time=$(echo "$end_time - $start_time" | bc 2>/dev/null || echo "N/A")
        
        echo "[$timestamp] $connection: CONNECTED (${response_time}s)" >> "$MONITOR_LOG"
        echo "‚úÖ $connection: Connected (${response_time}s)"
    else
        echo "[$timestamp] $connection: FAILED" >> "$MONITOR_LOG"
        echo "‚ùå $connection: Connection failed"
    fi
}

# Monitor multiple connections
connections=("oracle3dove")

echo "üîç SSH Connection Monitor - $(date)"
echo "=================================="

for conn in "${connections[@]}"; do
    test_and_log "$conn"
done

echo ""
echo "üìÑ Recent performance log:"
tail -5 "$MONITOR_LOG" 2>/dev/null || echo "No previous logs"
EOF

    chmod +x ~/workshop_admin/scripts/connection_monitor.sh
    echo "üìä Connection monitor created: ~/workshop_admin/scripts/connection_monitor.sh"
}

# Main performance optimization workflow
main_optimization() {
    echo "üéØ Starting SSH performance optimization..."
    
    # Test current performance
    echo "üìä BASELINE PERFORMANCE TEST"
    echo "============================"
    test_connection_performance "oracle3dove"
    
    # Ask user what optimizations to apply
    echo ""
    echo "‚ö° AVAILABLE OPTIMIZATIONS"
    echo "========================="
    echo "1) Optimize SSH configuration"
    echo "2) Optimize SSH keys"
    echo "3) Full optimization (config + keys)"
    echo "4) Create performance monitor"
    echo "5) Skip optimizations"
    echo ""
    
    read -p "Choose optimization (1-5): " opt_choice
    
    case $opt_choice in
        1)
            optimize_ssh_config
            echo ""
            echo "üîÑ Testing optimized configuration..."
            test_connection_performance "oracle3dove"
            ;;
        2)
            optimize_ssh_keys
            ;;
        3)
            optimize_ssh_config
            optimize_ssh_keys
            echo ""
            echo "üîÑ Testing fully optimized setup..."
            test_connection_performance "oracle3dove"
            ;;
        4)
            create_connection_monitor
            ~/workshop_admin/scripts/connection_monitor.sh
            ;;
        5)
            echo "‚è≠Ô∏è Skipping optimizations"
            ;;
        *)
            echo "‚ùå Invalid choice"
            ;;
    esac
    
    echo ""
    echo "üìã OPTIMIZATION SUMMARY"
    echo "======================"
    echo "‚úÖ SSH performance optimization completed"
    echo ""
    echo "üîß Additional performance tips:"
    echo "   ‚Ä¢ Use connection multiplexing for multiple sessions"
    echo "   ‚Ä¢ Enable compression for slow connections"
    echo "   ‚Ä¢ Use SSH keys instead of passwords"
    echo "   ‚Ä¢ Keep SSH agent running for key management"
    echo "   ‚Ä¢ Monitor connection performance regularly"
}

# Run main optimization
main_optimization
```

---

## **Part 5: Final Challenge - Remote Administration Master (15 minutes)**

### **Global Workshop Emergency Response Challenge**

```bash
#!/bin/bash
# Global Workshop Emergency Response Challenge

echo "üö® GLOBAL WORKSHOP EMERGENCY RESPONSE CHALLENGE"
echo "=============================================="

CHALLENGE_DIR="$HOME/workshop_challenge_remote"
mkdir -p "$CHALLENGE_DIR"/{scenarios,logs,reports}

echo ""
echo "üéØ EMERGENCY SCENARIO:"
echo "Your London workshop (oracle3dove) has reported critical issues:"
echo "‚Ä¢ System performance degraded significantly"
echo "‚Ä¢ Some services are unresponsive"  
echo "‚Ä¢ File synchronization has failed"
echo "‚Ä¢ Staff cannot access shared resources"
echo ""
echo "‚è∞ TIME LIMIT: 15 minutes"
echo "üéñÔ∏è MISSION OBJECTIVES:"
echo "‚úÖ 1. Establish secure connection to remote workshop"
echo "‚úÖ 2. Diagnose system performance issues"
echo "‚úÖ 3. Restore critical services"
echo "‚úÖ 4. Repair file synchronization"
echo "‚úÖ 5. Generate incident report"
echo "‚úÖ 6. Implement preventive measures"

# Create challenge evaluation script
cat > "$CHALLENGE_DIR/evaluate_challenge.sh" << 'EOF'
#!/bin/bash
# Remote Administration Master Challenge Evaluation

echo "üèÜ REMOTE ADMINISTRATION MASTER EVALUATION"
echo "=========================================="

score=0
total_possible=100

echo "üìã EVALUATING YOUR REMOTE ADMINISTRATION MASTERY..."
echo ""

# Check 1: SSH Configuration (15 points)
if [ -f ~/.ssh/config ] && grep -q "oracle3dove" ~/.ssh/config; then
    echo "‚úÖ SSH configuration properly set up (+15 points)"
    score=$((score + 15))
else
    echo "‚ùå SSH configuration missing or incomplete (0 points)"
fi

# Check 2: SSH Keys (15 points)
if [ -f ~/.ssh/id_rsa ] && [ -f ~/.ssh/id_rsa.pub ]; then
    key_bits=$(ssh-keygen -lf ~/.ssh/id_rsa 2>/dev/null | awk '{print $1}')
    if [ "$key_bits" -ge 2048 ]; then
        echo "‚úÖ Strong SSH keys configured (+15 points)"
        score=$((score + 15))
    else
        echo "‚ö†Ô∏è SSH keys exist but could be stronger (+10 points)"
        score=$((score + 10))
    fi
else
    echo "‚ùå SSH keys not properly configured (0 points)"
fi

# Check 3: Connection Testing (10 points)
if ssh -o ConnectTimeout=10 oracle3dove 'exit' 2>/dev/null; then
    echo "‚úÖ Remote connection working (+10 points)"
    score=$((score + 10))
else
    echo "‚ùå Remote connection failed (0 points)"
fi

# Check 4: File Transfer Capability (15 points)
if command -v scp >/dev/null && command -v rsync >/dev/null; then
    echo "‚úÖ File transfer tools available (+15 points)"
    score=$((score + 15))
else
    echo "‚ö†Ô∏è Some file transfer tools missing (+5 points)"
    score=$((score + 5))
fi

# Check 5: Service Management (15 points)
if [ -d ~/workshop_services ]; then
    echo "‚úÖ Service management system created (+15 points)"
    score=$((score + 15))
else
    echo "‚ùå Service management system not found (0 points)"
fi

# Check 6: System Administration Tools (15 points)
if [ -d ~/workshop_admin ]; then
    echo "‚úÖ Administration toolkit created (+15 points)"
    score=$((score + 15))
else
    echo "‚ùå Administration toolkit not found (0 points)"
fi

# Check 7: Troubleshooting Knowledge (10 points)
echo "‚úÖ Troubleshooting procedures learned (+10 points)"
score=$((score + 10))

# Check 8: Performance Optimization (5 points)
if grep -q "ControlMaster\|Compression" ~/.ssh/config 2>/dev/null; then
    echo "‚úÖ SSH performance optimizations applied (+5 points)"
    score=$((score + 5))
else
    echo "‚ö†Ô∏è Basic performance optimizations missing (+2 points)"
    score=$((score + 2))
fi

# Final evaluation
echo ""
echo "üìä FINAL EVALUATION"
echo "=================="
echo "Total Score: $score/$total_possible"
echo ""

if [ $score -ge 90 ]; then
    echo "üèÜ CERTIFICATION LEVEL: EXPERT REMOTE ADMINISTRATOR"
    echo "üéâ Outstanding! You've mastered global workshop management"
    echo ""
    echo "üåü Expert Capabilities Achieved:"
    echo "   ‚Ä¢ Secure multi-server remote access"
    echo "   ‚Ä¢ Advanced SSH configuration and optimization"
    echo "   ‚Ä¢ Professional file transfer and synchronization"
    echo "   ‚Ä¢ Comprehensive service management"
    echo "   ‚Ä¢ System administration and maintenance"
    echo "   ‚Ä¢ Emergency response procedures"
    
elif [ $score -ge 75 ]; then
    echo "ü•à CERTIFICATION LEVEL: ADVANCED REMOTE SPECIALIST"
    echo "üëç Great work! You have strong remote management skills"
    echo ""
    echo "üéØ Advanced Capabilities:"
    echo "   ‚Ä¢ Reliable remote server connectivity"
    echo "   ‚Ä¢ Effective file transfer operations"
    echo "   ‚Ä¢ Service monitoring and management"
    echo "   ‚Ä¢ Basic system administration"
    
elif [ $score -ge 60 ]; then
    echo "ü•â CERTIFICATION LEVEL: REMOTE TECHNICIAN"
    echo "üëå Good job! You understand remote administration basics"
    echo ""
    echo "üìö Areas for improvement:"
    echo "   ‚Ä¢ SSH configuration optimization"
    echo "   ‚Ä¢ Advanced troubleshooting techniques"
    echo "   ‚Ä¢ Performance tuning"
    
else
    echo "üìö CERTIFICATION LEVEL: REMOTE APPRENTICE"
    echo "üéØ Keep practicing! Review the areas you missed"
    echo ""
    echo "üìñ Focus on:"
    echo "   ‚Ä¢ SSH setup and configuration"
    echo "   ‚Ä¢ Basic remote connection skills"
    echo "   ‚Ä¢ File transfer fundamentals"
fi

echo ""
echo "üöÄ NEXT STEPS FOR CONTINUED MASTERY:"
echo "   ‚Ä¢ Practice with multiple remote servers"
echo "   ‚Ä¢ Learn advanced SSH tunneling techniques"
echo "   ‚Ä¢ Master automated deployment scripts"
echo "   ‚Ä¢ Study enterprise remote management tools"
EOF

chmod +x "$CHALLENGE_DIR/evaluate_challenge.sh"

# Create challenge tasks
cat > "$CHALLENGE_DIR/challenge_tasks.sh" << 'EOF'
#!/bin/bash
# Challenge Task Helper

echo "üéØ REMOTE ADMINISTRATION CHALLENGE TASKS"
echo "========================================"
echo ""
echo "üìã QUICK TASK CHECKLIST:"
echo "‚ñ° 1. Test SSH connection: ssh oracle3dove"
echo "‚ñ° 2. Check system performance: ssh oracle3dove 'top -bn1 | head -20'"
echo "‚ñ° 3. Check disk space: ssh oracle3dove 'df -h'"
echo "‚ñ° 4. Check services: ssh oracle3dove 'systemctl status ssh networking'"
echo "‚ñ° 5. Transfer test file: scp testfile.txt oracle3dove:~/"
echo "‚ñ° 6. Create system report: ssh oracle3dove 'uptime; free -h; df -h' > system_report.txt"
echo "‚ñ° 7. Fix any issues found"
echo "‚ñ° 8. Document actions taken"
echo ""
echo "‚ö° SPEED COMMANDS:"
echo "ssh oracle3dove 'hostname; uptime; free -h | grep Mem; df -h /' # Quick health check"
echo "ssh oracle3dove 'systemctl is-active ssh networking systemd-resolved' # Service check"
echo "scp oracle3dove:/var/log/syslog ./syslog_backup.txt # Get logs"
echo ""
echo "üèÅ When completed, run: $CHALLENGE_DIR/evaluate_challenge.sh"
EOF

chmod +x "$CHALLENGE_DIR/challenge_tasks.sh"

echo ""
echo "üöÄ EMERGENCY RESPONSE CHALLENGE ACTIVATED!"
echo ""
echo "üìã Challenge Resources:"
echo "   üéØ Task checklist: $CHALLENGE_DIR/challenge_tasks.sh"
echo "   üèÜ Evaluation: $CHALLENGE_DIR/evaluate_challenge.sh"
echo ""
echo "‚è∞ Timer starting now - you have 15 minutes!"
echo ""

# Display challenge tasks
$CHALLENGE_DIR/challenge_tasks.sh

echo ""
read -p "Press Enter when you've completed all tasks to run evaluation..."

# Run evaluation
$CHALLENGE_DIR/evaluate_challenge.sh
```

---

## **Session Wrap-Up & Global Operations Mastery (10 minutes)**

### **Visual Achievement Map**

```
üåç YOUR GLOBAL WORKSHOP EMPIRE MASTERY
======================================

üéØ REMOTE ADMINISTRATION SKILLS MASTERED:
‚îú‚îÄ‚îÄ üîê Advanced SSH Configuration
‚îÇ   ‚îú‚îÄ‚îÄ Key-based authentication setup
‚îÇ   ‚îú‚îÄ‚îÄ Connection multiplexing optimization
‚îÇ   ‚îú‚îÄ‚îÄ Performance tuning and compression
‚îÇ   ‚îî‚îÄ‚îÄ Professional configuration management
‚îÇ
‚îú‚îÄ‚îÄ üìÅ Professional File Operations
‚îÇ   ‚îú‚îÄ‚îÄ Secure file transfer protocols
‚îÇ   ‚îú‚îÄ‚îÄ Automated synchronization systems
‚îÇ   ‚îú‚îÄ‚îÄ Integrity verification methods
‚îÇ   ‚îî‚îÄ‚îÄ Backup and recovery procedures
‚îÇ
‚îú‚îÄ‚îÄ üõ†Ô∏è Remote Service Management
‚îÇ   ‚îú‚îÄ‚îÄ Multi-server monitoring dashboards
‚îÇ   ‚îú‚îÄ‚îÄ Automated service health checking
‚îÇ   ‚îú‚îÄ‚îÄ Remote maintenance procedures
‚îÇ   ‚îî‚îÄ‚îÄ Emergency response protocols
‚îÇ
‚îú‚îÄ‚îÄ üîß System Administration
‚îÇ   ‚îú‚îÄ‚îÄ Remote performance monitoring
‚îÇ   ‚îú‚îÄ‚îÄ Batch operations across servers
‚îÇ   ‚îú‚îÄ‚îÄ System health reporting
‚îÇ   ‚îî‚îÄ‚îÄ Maintenance automation
‚îÇ
‚îî‚îÄ‚îÄ üö® Troubleshooting & Recovery
    ‚îú‚îÄ‚îÄ Connection diagnostic procedures
    ‚îú‚îÄ‚îÄ Performance optimization techniques
    ‚îú‚îÄ‚îÄ Issue resolution workflows
    ‚îî‚îÄ‚îÄ Preventive maintenance planning

üåü PROFESSIONAL CAPABILITIES ACHIEVED:
‚úÖ Manage multiple remote workshops simultaneously
‚úÖ Secure and optimize remote connections
‚úÖ Automate file synchronization across locations
‚úÖ Monitor and maintain remote services
‚úÖ Respond to emergencies from anywhere
‚úÖ Generate professional system reports
‚úÖ Implement preventive maintenance schedules
‚úÖ Troubleshoot complex connectivity issues
```

### **Daily Remote Administrator Toolkit**

```bash
# Your new daily commands as Global Operations Director:
ssh oracle3dove                                    # Connect to primary workshop
~/workshop_services/scripts/service_monitor.sh     # Check all services
~/workshop_transfers/sync_monitor.sh status        # Check synchronization
~/workshop_admin/scripts/connection_monitor.sh     # Test all connections

# Emergency response commands:
ssh oracle3dove 'uptime; free -h; df -h'          # Quick health check
ssh oracle3dove 'systemctl status nginx mysql'     # Critical services
~/workshop_admin/scripts/emergency_response.sh     # Emergency procedures

# File operations:
scp important_file.txt oracle3dove:~/backup/       # Secure file transfer
rsync -avz ./local_folder/ oracle3dove:~/remote/   # Directory sync
```

### **Key Takeaways for Global Workshop Directors**

1. **Security First**: Always use key-based authentication and encrypted connections
2. **Automate Everything**: Create scripts for routine tasks and monitoring
3. **Monitor Proactively**: Set up automated alerts for issues
4. **Document Procedures**: Keep detailed logs and incident reports
5. **Optimize Performance**: Fine-tune connections for efficiency
6. **Plan for Emergencies**: Have response procedures ready
7. **Regular Maintenance**: Schedule preventive maintenance tasks

### **Next Session Preview**
*"Tomorrow we tackle the ultimate challenge - complete system troubleshooting and disaster recovery. You'll learn to handle catastrophic failures, data corruption, security breaches, and how to restore operations when everything goes wrong. Your remote administration skills become crisis management expertise!"*

---

## **Homework Assignment**

**Mission**: Set up a complete remote administration system for managing distributed workshops

**Deliverables**:
1. **SSH Infrastructure** - Optimized configuration with key-based authentication
2. **Monitoring Dashboard** - Automated service and performance monitoring  
3. **File Synchronization** - Automated backup and sync between locations
4. **Emergency Procedures** - Documented response plans for common issues
5. **Administration Scripts** - Custom tools for routine management tasks

**Success Criteria**: Can diagnose and resolve remote system issues within 10 minutes from anywhere in the world!

üéâ **Congratulations! You're now a certified Global Workshop Operations Director!** # Week 3 Session 2: Remote Administration (Enhanced)
## "Managing Your Global Workshop Empire" üåç

### **Story Context**
*Your workshop empire has expanded globally! You now have facilities in London, Tokyo, New York, and Sydney - all operating 24/7. Flying between locations isn't practical, so today you'll master the art of remote workshop management. Think of yourself as the Global Operations Director, capable of managing any workshop anywhere in the world from your command center.*

---

## **Visual Learning: Global Workshop Network Architecture**

```
üåç GLOBAL WORKSHOP EMPIRE NETWORK
=================================

    üì± YOUR COMMAND CENTER (Local Machine)
            ‚ÜïÔ∏è SSH Tunnels (Encrypted)
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ  üè≠ REMOTE WORKSHOPS WORLDWIDE       ‚îÇ
    ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îÇ
    ‚îÇ  ‚îÇ LONDON   ‚îÇ  ‚îÇ TOKYO    ‚îÇ         ‚îÇ
    ‚îÇ  ‚îÇ üá¨üáß WS-1  ‚îÇ  ‚îÇ üáØüáµ WS-2  ‚îÇ         ‚îÇ
    ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îÇ
    ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îÇ
    ‚îÇ  ‚îÇ NEW YORK ‚îÇ  ‚îÇ SYDNEY   ‚îÇ         ‚îÇ
    ‚îÇ  ‚îÇ üá∫üá∏ WS-3  ‚îÇ  ‚îÇ üá¶üá∫ WS-4  ‚îÇ         ‚îÇ
    ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üîê SECURE CONNECTION TYPES:
‚îú‚îÄ‚îÄ üîë Password Authentication (Basic)
‚îú‚îÄ‚îÄ üé´ Key-Based Authentication (Advanced)
‚îú‚îÄ‚îÄ üìã Config-Based Access (Professional)
‚îî‚îÄ‚îÄ üõ°Ô∏è Certificate Authentication (Enterprise)

üéØ MANAGEMENT CAPABILITIES:
‚úÖ Real-time monitoring of all locations
‚úÖ File synchronization between workshops  
‚úÖ Remote service management
‚úÖ Emergency response coordination
‚úÖ Performance optimization across regions
```

---

## **Part 1: Advanced SSH Mastery (35 minutes)**

### **A. SSH Connection Optimization (20 minutes)**

#### **Professional SSH Configuration System**

```bash
#!/bin/bash
# Advanced SSH Configuration Builder

echo "üîß PROFESSIONAL SSH CONFIGURATION SETUP"
echo "========================================"

SSH_DIR="$HOME/.ssh"
mkdir -p "$SSH_DIR"

# Create advanced SSH configuration
cat > "$SSH_DIR/config" << 'EOF'
# Global Workshop Empire SSH Configuration
# ========================================

# Default settings for all connections
Host *
    ServerAliveInterval 60
    ServerAliveCountMax 3
    TCPKeepAlive yes
    Compression yes
    ForwardAgent yes
    AddKeysToAgent yes
    IdentitiesOnly yes

# Primary Workshop Server (Oracle3dove)
Host oracle3dove workshop-main primary
    HostName 79.72.72.205
    User champion
    Port 22
    IdentityFile ~/.ssh/id_rsa
    LocalForward 8080 localhost:80
    RemoteForward 9090 localhost:9090
    RequestTTY yes
    
# Development Environment
Host dev-workshop
    HostName 192.168.1.100
    User developer  
    Port 22
    IdentityFile ~/.ssh/id_rsa_dev
    ProxyJump oracle3dove
    
# Production Environment  
Host prod-workshop
    HostName 10.0.0.50
    User admin
    Port 2222
    IdentityFile ~/.ssh/id_rsa_prod
    StrictHostKeyChecking yes
    UserKnownHostsFile ~/.ssh/known_hosts_prod

# Emergency Access (Different Key)
Host emergency
    HostName 79.72.72.205
    User champion
    Port 22
    IdentityFile ~/.ssh/id_rsa_emergency
    ConnectTimeout 10
EOF

chmod 600 "$SSH_DIR/config"

echo "‚úÖ Professional SSH configuration created!"
echo ""
echo "üéØ Available Connection Shortcuts:"
echo "   ssh oracle3dove     # Primary workshop"
echo "   ssh workshop-main   # Same as above (alias)"
echo "   ssh primary         # Another alias"
echo "   ssh dev-workshop    # Development environment"
echo "   ssh prod-workshop   # Production environment"
echo "   ssh emergency       # Emergency access"
```

#### **SSH Key Management System**

```bash
#!/bin/bash
# Professional SSH Key Management

echo "üîë SSH KEY MANAGEMENT SYSTEM"
echo "============================"

# Function to create specialized SSH keys
create_specialized_keys() {
    echo "Creating specialized SSH key pairs..."
    
    # Main production key
    if [ ! -f ~/.ssh/id_rsa ]; then
        ssh-keygen -t rsa -b 4096 -C "$(whoami)@$(hostname)-main" -f ~/.ssh/id_rsa -N ""
        echo "‚úÖ Main production key created"
    fi
    
    # Development key
    if [ ! -f ~/.ssh/id_rsa_dev ]; then
        ssh-keygen -t rsa -b 4096 -C "$(whoami)@$(hostname)-dev" -f ~/.ssh/id_rsa_dev -N ""
        echo "‚úÖ Development key created"
    fi
    
    # Emergency key
    if [ ! -f ~/.ssh/id_rsa_emergency ]; then
        ssh-keygen -t rsa -b 4096 -C "$(whoami)@$(hostname)-emergency" -f ~/.ssh/id_rsa_emergency -N ""
        echo "‚úÖ Emergency key created"
    fi
}

# Function to deploy keys to servers
deploy_keys() {
    echo ""
    echo "üöÄ KEY DEPLOYMENT TO SERVERS"
    echo "============================"
    
    read -p "Deploy main key to oracle3dove? (y/n): " deploy_main
    if [ "$deploy_main" = "y" ]; then
        echo "Deploying main key..."
        ssh-copy-id -i ~/.ssh/id_rsa.pub champion@79.72.72.205
        echo "‚úÖ Main key deployed to oracle3dove"
    fi
    
    echo ""
    echo "üìä KEY DEPLOYMENT STATUS:"
    echo "========================="
    for key in ~/.ssh/id_rsa*.pub; do
        if [ -f "$key" ]; then
            keyname=$(basename "$key" .pub)
            fingerprint=$(ssh-keygen -lf "$key" | awk '{print $2}')
            echo "üîë $keyname: $fingerprint"
        fi
    done
}

# Function to test all connections
test_connections() {
    echo ""
    echo "üîç TESTING ALL SSH CONNECTIONS"
    echo "=============================="
    
    # Test primary connection
    echo "Testing primary connection..."
    if ssh -o ConnectTimeout=10 oracle3dove 'echo "‚úÖ Primary connection successful"' 2>/dev/null; then
        echo "‚úÖ oracle3dove: CONNECTED"
    else
        echo "‚ùå oracle3dove: FAILED"
    fi
    
    # Test with different aliases
    for alias in workshop-main primary; do
        echo "Testing $alias..."
        if ssh -o ConnectTimeout=10 "$alias" 'exit' 2>/dev/null; then
            echo "‚úÖ $alias: CONNECTED"
        else
            echo "‚ùå $alias: FAILED"
        fi
    done
}

# Execute key management
create_specialized_keys
deploy_keys
test_connections

echo ""
echo "üéâ SSH KEY MANAGEMENT COMPLETE!"
echo ""
echo "üîß Key Management Commands:"
echo "   ssh-add -l                    # List loaded keys"
echo "   ssh-add ~/.ssh/id_rsa         # Load specific key"
echo "   ssh-keygen -lf keyfile        # Show key fingerprint"
echo "   ssh-copy-id user@server       # Deploy key to server"
```

### **B. Connection Testing and Diagnostics (15 minutes)**

#### **Advanced Connection Diagnostics**

```bash
#!/bin/bash
# SSH Connection Diagnostic Suite

echo "üîç SSH CONNECTION DIAGNOSTIC SUITE"
echo "=================================="

# Function to test basic connectivity
test_basic_connectivity() {
    local host=$1
    echo "üåê Testing basic connectivity to $host..."
    
    if ping -c 3 "$host" >/dev/null 2>&1; then
        echo "‚úÖ Ping successful"
        ping_time=$(ping -c 3 "$host" | tail -1 | awk -F'/' '{print $5}')
        echo "üìä Average response time: ${ping_time}ms"
    else
        echo "‚ùå Ping failed - server may be down or blocking ICMP"
    fi
}

# Function to test SSH port accessibility
test_ssh_port() {
    local host=$1
    local port=${2:-22}
    echo ""
    echo "üîå Testing SSH port accessibility..."
    
    if timeout 10 bash -c "echo >/dev/tcp/$host/$port" 2>/dev/null; then
        echo "‚úÖ Port $port is open on $host"
    else
        echo "‚ùå Port $port is not accessible on $host"
    fi
}

# Function to test SSH authentication
test_ssh_auth() {
    local connection=$1
    echo ""
    echo "üîê Testing SSH authentication..."
    
    # Test with verbose output
    ssh -v -o ConnectTimeout=10 -o BatchMode=yes "$connection" 'echo "Authentication successful"' 2>/tmp/ssh_debug.log
    
    if [ $? -eq 0 ]; then
        echo "‚úÖ SSH authentication successful"
        
        # Get connection details
        ssh "$connection" 'echo "üè† Remote hostname: $(hostname)"'
        ssh "$connection" 'echo "üë§ Remote user: $(whoami)"'
        ssh "$connection" 'echo "üìÖ Remote time: $(date)"'
        ssh "$connection" 'echo "‚è±Ô∏è  Remote uptime: $(uptime -p)"'
    else
        echo "‚ùå SSH authentication failed"
        echo "üîç Debug information:"
        grep -E "debug1|Permission denied|Connection refused" /tmp/ssh_debug.log | tail -5
    fi
}

# Function to test connection performance
test_connection_performance() {
    local connection=$1
    echo ""
    echo "‚ö° Testing connection performance..."
    
    # Test command execution speed
    echo "Testing command execution speed..."
    start_time=$(date +%s.%N)
    ssh "$connection" 'uname -a' >/dev/null 2>&1
    end_time=$(date +%s.%N)
    
    execution_time=$(echo "$end_time - $start_time" | bc 2>/dev/null || echo "N/A")
    echo "üìä Command execution time: ${execution_time}s"
    
    # Test data transfer speed
    echo "Testing small data transfer..."
    start_time=$(date +%s.%N)
    echo "test data" | ssh "$connection" 'cat > /tmp/speed_test.txt'
    end_time=$(date +%s.%N)
    
    transfer_time=$(echo "$end_time - $start_time" | bc 2>/dev/null || echo "N/A")
    echo "üìä Small data transfer time: ${transfer_time}s"
    
    # Clean up test file
    ssh "$connection" 'rm -f /tmp/speed_test.txt' 2>/dev/null
}

# Main diagnostic execution
echo "Starting comprehensive SSH diagnostics..."
echo ""

# Test the primary connection
HOST="79.72.72.205"
CONNECTION="oracle3dove"

test_basic_connectivity "$HOST"
test_ssh_port "$HOST" 22
test_ssh_auth "$CONNECTION"
test_connection_performance "$CONNECTION"

echo ""
echo "üéØ DIAGNOSTIC SUMMARY"
echo "===================="
echo "‚úÖ Comprehensive SSH diagnostics completed"
echo "üìÅ Debug logs saved to: /tmp/ssh_debug.log"
echo "üîß If issues found, check:"
echo "   ‚Ä¢ Network connectivity (ping)"
echo "   ‚Ä¢ SSH service status on remote server"
echo "   ‚Ä¢ SSH key deployment and permissions"
echo "   ‚Ä¢ Firewall settings on both ends"
```

---

## **Part 2: Professional File Transfer Operations (30 minutes)**

### **A. Advanced SCP Operations (15 minutes)**

#### **Professional File Transfer Suite**

```bash
#!/bin/bash
# Professional File Transfer Management System

echo "üìÅ PROFESSIONAL FILE TRANSFER SUITE"
echo "==================================="

# Create directories for organized file operations
mkdir -p ~/workshop_transfers/{incoming,outgoing,backups,logs}

# Function to log all transfer operations
log_transfer() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> ~/workshop_transfers/logs/transfer.log
}

# Function for secure file upload
secure_upload() {
    local source_file="$1"
    local destination="$2"
    local remote_path="$3"
    
    echo "üì§ SECURE FILE UPLOAD"
    echo "===================="
    echo "Source: $source_file"
    echo "Destination: $destination"
    echo "Remote path: $remote_path"
    
    if [ ! -f "$source_file" ]; then
        echo "‚ùå Source file not found: $source_file"
        return 1
    fi
    
    # Create backup before transfer
    backup_name="$(basename "$source_file").backup.$(date +%Y%m%d_%H%M%S)"
    cp "$source_file" ~/workshop_transfers/backups/"$backup_name"
    log_transfer "BACKUP: Created backup of $source_file as $backup_name"
    
    # Calculate file checksum for verification
    local_checksum=$(sha256sum "$source_file" | awk '{print $1}')
    echo "üìä Local file checksum: $local_checksum"
    
    # Perform the transfer
    echo "üöÄ Starting secure transfer..."
    if scp -p "$source_file" "$destination:$remote_path"; then
        echo "‚úÖ Upload successful"
        
        # Verify checksum on remote side
        remote_checksum=$(ssh "$destination" "sha256sum '$remote_path/$(basename "$source_file")'" | awk '{print $1}')
        echo "üìä Remote file checksum: $remote_checksum"
        
        if [ "$local_checksum" = "$remote_checksum" ]; then
            echo "‚úÖ File integrity verified"
            log_transfer "UPLOAD SUCCESS: $source_file to $destination:$remote_path (checksum verified)"
        else
            echo "‚ö†Ô∏è Checksum mismatch - file may be corrupted"
            log_transfer "UPLOAD WARNING: Checksum mismatch for $source_file"
        fi
    else
        echo "‚ùå Upload failed"
        log_transfer "UPLOAD FAILED: $source_file to $destination:$remote_path"
        return 1
    fi
}

# Function for secure file download
secure_download() {
    local remote_connection="$1"
    local remote_file="$2"
    local local_path="$3"
    
    echo "üì• SECURE FILE DOWNLOAD"
    echo "======================"
    echo "Remote: $remote_connection:$remote_file"
    echo "Local path: $local_path"
    
    # Check if remote file exists
    if ! ssh "$remote_connection" "test -f '$remote_file'"; then
        echo "‚ùå Remote file not found: $remote_file"
        return 1
    fi
    
    # Get remote file info
    remote_size=$(ssh "$remote_connection" "stat -c%s '$remote_file'")
    remote_checksum=$(ssh "$remote_connection" "sha256sum '$remote_file'" | awk '{print $1}')
    
    echo "üìä Remote file size: $(numfmt --to=iec $remote_size)"
    echo "üìä Remote file checksum: $remote_checksum"
    
    # Perform the download
    echo "üöÄ Starting secure download..."
    if scp -p "$remote_connection:$remote_file" "$local_path"; then
        echo "‚úÖ Download successful"
        
        # Verify local file
        local_checksum=$(sha256sum "$local_path/$(basename "$remote_file")" | awk '{print $1}')
        echo "üìä Local file checksum: $local_checksum"
        
        if [ "$remote_checksum" = "$local_checksum" ]; then
            echo "‚úÖ File integrity verified"
            log_transfer "DOWNLOAD SUCCESS: $remote_connection:$remote_file to $local_path (checksum verified)"
        else
            echo "‚ö†Ô∏è Checksum mismatch - file may be corrupted"
            log_transfer "DOWNLOAD WARNING: Checksum mismatch for $remote_file"
        fi
    else
        echo "‚ùå Download failed"
        log_transfer "DOWNLOAD FAILED: $remote_connection:$remote_file to $local_path"
        return 1
    fi
}

# Function for directory synchronization
sync_directories() {
    local local_dir="$1"
    local remote_connection="$2"
    local remote_dir="$3"
    local direction="$4"  # "upload" or "download"
    
    echo "üîÑ DIRECTORY SYNCHRONIZATION"
    echo "=========================="
    
    case $direction in
        "upload")
            echo "üì§ Syncing $local_dir to $remote_connection:$remote_dir"
            rsync -avz --progress "$local_dir/" "$remote_connection:$remote_dir/"
            ;;
        "download")
            echo "üì• Syncing $remote_connection:$remote_dir to $local_dir"
            rsync -avz --progress "$remote_connection:$remote_dir/" "$local_dir/"
            ;;
        *)
            echo "‚ùå Invalid direction. Use 'upload' or 'download'"
            return 1
            ;;
    esac
    
    log_transfer "SYNC: $direction between $local_dir and $remote_connection:$remote_dir"
}

echo "üéØ File Transfer Functions Loaded!"
echo ""
echo "üìã Available Commands:"
echo "   secure_upload 'file.txt' 'oracle3dove' '/home/champion/'"
echo "   secure_download 'oracle3dove' '/home/champion/file.txt' './'"
echo "   sync_directories './local_folder' 'oracle3dove' '/home/champion/remote_folder' 'upload'"
echo ""

# Interactive transfer menu
transfer_menu() {
    echo "üéØ TRANSFER OPERATIONS MENU"
    echo "=========================="
    echo "1) Upload file to remote server"
    echo "2) Download file from remote server"
    echo "3) Sync directory to remote server"
    echo "4) Sync directory from remote server"
    echo "5) View transfer logs"
    echo "6) Exit"
    echo ""
}

while true; do
    transfer_menu
    read -p "Choose operation (1-6): " choice
    
    case $choice in
        1)
            read -p "Local file path: " local_file
            read -p "Remote connection (e.g., oracle3dove): " remote_conn
            read -p "Remote directory: " remote_dir
            secure_upload "$local_file" "$remote_conn" "$remote_dir"
            ;;
        2)
            read -p "Remote connection: " remote_conn
            read -p "Remote file path: " remote_file
            read -p "Local directory: " local_dir
            secure_download "$remote_conn" "$remote_file" "$local_dir"
            ;;
        3)
            read -p "Local directory: " local_dir
            read -p "Remote connection: " remote_conn
            read -p "Remote directory: " remote_dir
            sync_directories "$local_dir" "$remote_conn" "$remote_dir" "upload"
            ;;
        4)
            read -p "Remote connection: " remote_conn
            read -p "Remote directory: " remote_dir
            read -p "Local directory: " local_dir
            sync_directories "$local_dir" "$remote_conn" "$remote_dir" "download"
            ;;
        5)
            echo "üìã Recent Transfer Logs:"
            tail -20 ~/workshop_transfers/logs/transfer.log 2>/dev/null || echo "No logs found"
            ;;
        6)
            echo "üëã Exiting transfer operations"
            break
            ;;
        *)
            echo "‚ùå Invalid choice"
            ;;
    esac
    echo ""
    read -p "Press Enter to continue..."
done
```

### **B. Automated File Operations (15 minutes)**

#### **Workshop File Synchronization System**

```bash
#!/bin/bash
# Automated Workshop File Synchronization

echo "üîÑ WORKSHOP FILE SYNCHRONIZATION SYSTEM"
echo "======================================="

SYNC_CONFIG="$HOME/.workshop_sync_config"
SYNC_LOG="$HOME/workshop_transfers/logs/sync.log"

# Function to create synchronization configuration
create_sync_config() {
    cat > "$SYNC_CONFIG" << 'EOF'
# Workshop Synchronization Configuration
# =====================================

# Primary workshop connection
PRIMARY_WORKSHOP="oracle3dove"

# Directories to synchronize
SYNC_DIRS=(
    "Documents::/home/champion/Documents"
    "Projects::/home/champion/Projects"
    "Scripts::/home/champion/Scripts"
    "Backups::/home/champion/Backups"
)

# Synchronization settings
SYNC_INTERVAL=3600  # Sync every hour
BACKUP_BEFORE_SYNC=true
VERIFY_CHECKSUMS=true
COMPRESS_TRANSFER=true
EOF

    echo "‚úÖ Synchronization configuration created: $SYNC_CONFIG"
}

# Function to perform automated sync
perform_auto_sync() {
    source "$SYNC_CONFIG" 2>/dev/null || {
        echo "‚ùå Configuration file not found. Creating default config..."
        create_sync_config
        source "$SYNC_CONFIG"
    }
    
    echo "üîÑ Starting automated synchronization..."
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] AUTO-SYNC: Starting synchronization" >> "$SYNC_LOG"
    
    for sync_pair in "${SYNC_DIRS[@]}"; do
        local_name=$(echo "$sync_pair" | cut -d':' -f1)
        remote_path=$(echo "$sync_pair" | cut -d':' -f3)
        local_path="$HOME/$local_name"
        
        echo ""
        echo "üìÅ Syncing $local_name..."
        
        # Check if local directory exists
        if [ ! -d "$local_path" ]; then
            echo "üìÇ Creating local directory: $local_path"
            mkdir -p "$local_path"
        fi
        
        # Backup before sync if enabled
        if [ "$BACKUP_BEFORE_SYNC" = "true" ]; then
            backup_name="${local_name}_backup_$(date +%Y%m%d_%H%M%S)"
            echo "üíæ Creating backup: $backup_name"
            tar -czf "$HOME/workshop_transfers/backups/$backup_name.tar.gz" -C "$local_path" . 2>/dev/null
        fi
        
        # Perform synchronization
        sync_options="-av"
        [ "$COMPRESS_TRANSFER" = "true" ] && sync_options="${sync_options}z"
        
        if rsync $sync_options --progress "$local_path/" "$PRIMARY_WORKSHOP:$remote_path/"; then
            echo "‚úÖ $local_name synchronized successfully"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] SYNC SUCCESS: $local_name" >> "$SYNC_LOG"
        else
            echo "‚ùå $local_name synchronization failed"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] SYNC FAILED: $local_name" >> "$SYNC_LOG"
        fi
    done
    
    echo ""
    echo "üéâ Automated synchronization completed!"
}

# Function to create sync monitoring script
create_sync_monitor() {
    cat > ~/workshop_transfers/sync_monitor.sh << 'EOF'
#!/bin/bash
# Workshop Synchronization Monitor

SYNC_SCRIPT="$0"
LOCK_FILE="/tmp/workshop_sync.lock"
PID_FILE="/tmp/workshop_sync.pid"

# Function to check if sync is already running
check_sync_running() {
    if [ -f "$LOCK_FILE" ]; then
        if [ -f "$PID_FILE" ]; then
            local pid=$(cat "$PID_FILE")
            if kill -0 "$pid" 2>/dev/null; then
                echo "‚ö†Ô∏è Synchronization already running (PID: $pid)"
                return 0
            else
                echo "üßπ Cleaning up stale lock files"
                rm -f "$LOCK_FILE" "$PID_FILE"
            fi
        fi
    fi
    return 1
}

# Function to start sync daemon
start_sync_daemon() {
    if check_sync_running; then
        return 1
    fi
    
    echo "üöÄ Starting synchronization daemon..."
    echo $$ > "$PID_FILE"
    touch "$LOCK_FILE"
    
    # Load configuration
    source "$HOME/.workshop_sync_config" 2>/dev/null || {
        echo "‚ùå Configuration not found"
        exit 1
    }
    
    while [ -f "$LOCK_FILE" ]; do
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Running scheduled sync..."
        bash -c "$(dirname "$0")/auto_sync.sh"
        
        echo "üò¥ Waiting $SYNC_INTERVAL seconds until next sync..."
        sleep "$SYNC_INTERVAL"
    done
    
    rm -f "$PID_FILE"
    echo "üõë Synchronization daemon stopped"
}

# Function to stop sync daemon
stop_sync_daemon() {
    if [ -f "$LOCK_FILE" ]; then
        rm -f "$LOCK_FILE"
        echo "üõë Stopping synchronization daemon..."
        
        if [ -f "$PID_FILE" ]; then
            local pid=$(cat "$PID_FILE")
            kill "$pid" 2>/dev/null
            rm -f "$PID_FILE"
            echo "‚úÖ Daemon stopped"
        fi
    else
        echo "‚ÑπÔ∏è No synchronization daemon running"
    fi
}

# Function to show sync status
show_sync_status() {
    echo "üìä SYNCHRONIZATION STATUS"
    echo "========================"
    
    if check_sync_running; then
        local pid=$(cat "$PID_FILE" 2>/dev/null)
        echo "‚úÖ Status: Running (PID: $pid)"
        echo "üìÖ Started: $(stat -c %y "$LOCK_FILE" 2>/dev/null)"
    else
        echo "‚ùå Status: Stopped"
    fi
    
    echo ""
    echo "üìã Recent Sync Activity:"
    tail -10 "$HOME/workshop_transfers/logs/sync.log" 2>/dev/null || echo "No logs found"
}

# Main menu
case "${1:-menu}" in
    "start")
        start_sync_daemon
        ;;
    "stop")
        stop_sync_daemon
        ;;
    "status")
        show_sync_status
        ;;
    "menu"|*)
        echo "üéØ WORKSHOP SYNC MONITOR"
        echo "======================="
        echo "Usage: $0 {start|stop|status}"
        echo ""
        show_sync_status
        ;;
esac
EOF

    chmod +x ~/workshop_transfers/sync_monitor.sh
    echo "‚úÖ Sync monitor created: ~/workshop_transfers/sync_monitor.sh"
}

# Initialize the synchronization system
create_sync_config
create_sync_monitor

echo ""
echo "üéØ SYNCHRONIZATION SYSTEM READY!"
echo "==============================="
echo ""
echo "üìã Available Commands:"
echo "   ~/workshop_transfers/sync_monitor.sh start    # Start auto-sync daemon"
echo "   ~/workshop_transfers/sync_monitor.sh stop     # Stop auto-sync daemon"
echo "   ~/workshop_transfers/sync_monitor.sh status   # Check sync status"
echo ""
echo "‚öôÔ∏è Configuration file: $SYNC_CONFIG"
echo "üìÑ Sync logs: $SYNC_LOG"
echo ""
read -p "Would you like to run a test synchronization now? (y/n): " run_test

if [ "$run_test" = "y" ]; then
    perform_auto_sync
else
    echo "üí° You can run manual sync anytime with the sync monitor script"
fi
```

---

## **Part 3: Remote Service Management (30 minutes)**

### **A. Service Monitoring Dashboard (15 minutes)**

#### **Workshop Service Control Center**

```bash
#!/bin/bash
# Workshop Service Management Control Center

echo "üéõÔ∏è WORKSHOP SERVICE CONTROL CENTER"
echo "=================================="

# Create service management directory
mkdir -p ~/workshop_services/{scripts,logs,configs}

# Function to check service status across multiple servers
check_all_services() {
    local servers=("oracle3dove")
    local services=("ssh" "networking" "systemd-resolved")
    
    echo "üîç MULTI-SERVER SERVICE STATUS CHECK"
    echo "===================================="
    
    for server in "${servers[@]}"; do
        echo ""
        echo "üè≠ Checking services on $server..."
        echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
        
        # Test connection first
        if ! ssh -o ConnectTimeout=5 "$server" 'exit' 2>/dev/null; then
            echo "‚ùå $server: CONNECTION FAILED"
            continue
        fi
        
        echo "‚úÖ $server: Connected"
        
        # Check each service
        for service in "${services[@]}"; do
            status=$(ssh "$server" "systemctl is-active $service 2>/dev/null" || echo "unknown")
            case $status in
                "active")
                    echo "  ‚úÖ $service: Running"
                    ;;
                "inactive"|"failed")
                    echo "  ‚ùå $service: Stopped/Failed"
                    ;;
                "unknown")
                    echo "  ‚ùì $service: Unknown/Not installed"
                    ;;
                *)
                    echo "  ‚ö†Ô∏è  $service: $status"
                    ;;
            esac
        done
        
        # Check system resources
        echo ""
        echo "üìä System Resources:"
        ssh "$server" "echo '  üíæ Memory: \$(free -h | grep Mem | awk \"{print \\\$3\"/\"\\\$2}\")'"
        ssh "$server" "echo '  üíΩ Disk: \$(df -h / | tail -1 | awk \"{print \\\$5}\")'"
        ssh "$server" "echo '  ‚ö° Load: \$(uptime | awk -F\"load average:\" \"{print \\\$2}\")'"
    done
}

# Interactive service management
manage_services() {
    echo ""
    echo "üéõÔ∏è SERVICE MANAGEMENT MENU"
    echo "========================="
    echo "1) Start a service"
    echo "2) Stop a service"
    echo "3) Restart a service"
    echo "4) Check service status"
    echo "5) View service logs"
    echo "6) Enable service (auto-start)"
    echo "7) Disable service"
    echo "8) Back to main menu"
    echo ""
    
    read -p "Choose operation (1-8): " choice
    
    case $choice in
        1|2|3|4|5|6|7)
            read -p "Enter server name (e.g., oracle3dove): " server
            read -p "Enter service name (e.g., nginx): " service
            
            case $choice in
                1)
                    echo "üöÄ Starting $service on $server..."
                    ssh "$server" "sudo systemctl start $service"
                    ;;
                2)
                    echo "üõë Stopping $service on $server..."
                    ssh "$server" "sudo systemctl stop $service"
                    ;;
                3)
                    echo "üîÑ Restarting $service on $server..."
                    ssh "$server" "sudo systemctl restart $service"
                    ;;
                4)
                    echo "üîç Checking $service status on $server..."
                    ssh "$server" "systemctl status $service"
                    ;;
                5)
                    echo "üìã Viewing $service logs on $server..."
                    ssh "$server" "journalctl -u $service --no-pager -n 20"
                    ;;
                6)
                    echo "‚ö° Enabling $service on $server..."
                    ssh "$server" "sudo systemctl enable $service"
                    ;;
                7)
                    echo "‚ùå Disabling $service on $server..."
                    ssh "$server" "sudo systemctl disable $service"
                    ;;
            esac
            
            # Show updated status
            echo ""
            echo "üìä Updated status:"
            ssh "$server" "systemctl is-active $service"
            ;;
        8)
            return
            ;;
        *)
            echo "‚ùå Invalid choice"
            ;;
    esac
}

# Function to create service monitoring script
create_service_monitor() {
    cat > ~/workshop_services/scripts/service_monitor.sh << 'EOF'
#!/bin/bash
# Automated Service Monitoring

MONITOR_CONFIG="$HOME/workshop_services/configs/monitor.conf"
MONITOR_LOG="$HOME/workshop_services/logs/monitor.log"

# Default monitoring configuration
create_default_config() {
    cat > "$MONITOR_CONFIG" << 'CONF_EOF'
# Service Monitoring Configuration
# ================================

# Servers to monitor
SERVERS=(
    "oracle3dove"
)

# Critical services to monitor
CRITICAL_SERVICES=(
    "ssh"
    "networking"
)

# Warning services (non-critical)
WARNING_SERVICES=(
    "systemd-resolved"
    "cron"
)

# Monitoring interval (seconds)
MONITOR_INTERVAL=300

# Alert settings
ENABLE_ALERTS=true
ALERT_EMAIL=""
CONF_EOF
}

# Load configuration
load_config() {
    if [ ! -f "$MONITOR_CONFIG" ]; then
        echo "Creating default monitoring configuration..."
        create_default_config
    fi
    source "$MONITOR_CONFIG"
}

# Function to log monitoring events
log_event() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$MONITOR_LOG"
}

# Function to send alerts (placeholder for email integration)
send_alert() {
    local severity=$1
    local message=$2
    
    log_event "ALERT [$severity]: $message"
    echo "üö® ALERT [$severity]: $message"
    
    # Future: Email integration
    if [ "$ENABLE_ALERTS" = "true" ] && [ -n "$ALERT_EMAIL" ]; then
        # echo "$message" | mail -s "Workshop Alert [$severity]" "$ALERT_EMAIL"
        echo "üìß Alert would be sent to: $ALERT_EMAIL"
    fi
}

# Function to check individual service
check_service() {
    local server=$1
    local service=$2
    local severity=$3
    
    if ssh -o ConnectTimeout=10 "$server" "systemctl is-active $service >/dev/null 2>&1"; then
        log_event "OK: $service on $server is running"
        return 0
    else
        send_alert "$severity" "$service on $server is not running"
        return 1
    fi
}

# Main monitoring loop
run_monitoring() {
    load_config
    
    echo "üîç Starting service monitoring..."
    log_event "MONITOR: Service monitoring started"
    
    while true; do
        echo "‚è∞ Running monitoring check at $(date '+%H:%M:%S')..."
        
        for server in "${SERVERS[@]}"; do
            # Test server connectivity
            if ! ssh -o ConnectTimeout=10 "$server" 'exit' 2>/dev/null; then
                send_alert "CRITICAL" "Cannot connect to server: $server"
                continue
            fi
            
            # Check critical services
            for service in "${CRITICAL_SERVICES[@]}"; do
                check_service "$server" "$service" "CRITICAL"
            done
            
            # Check warning services
            for service in "${WARNING_SERVICES[@]}"; do
                check_service "$server" "$service" "WARNING"
            done
        done
        
        echo "‚úÖ Monitoring check completed"
        sleep "$MONITOR_INTERVAL"
    done
}

# Command line interface
case "${1:-help}" in
    "start")
        run_monitoring
        ;;
    "config")
        nano "$MONITOR_CONFIG"
        ;;
    "logs")
        tail -f "$MONITOR_LOG"
        ;;
    "status")
        if pgrep -f "service_monitor.sh start" >/dev/null; then
            echo "‚úÖ Service monitor is running"
        else
            echo "‚ùå Service monitor is stopped"
        fi
        ;;
    *)
        echo "üéØ SERVICE MONITOR USAGE"
        echo "======================="
        echo "$0 start    # Start monitoring"
        echo "$0 config   # Edit configuration"
        echo "$0 logs     # View logs"
        echo "$0 status   # Check monitor status"
        ;;
esac
EOF

    chmod +x ~/workshop_services/scripts/service_monitor.sh
    echo "‚úÖ Service monitor created: ~/workshop_services/scripts/service_monitor.sh"
}

# Execute service management setup
check_all_services
create_service_monitor

echo ""
echo "üéØ SERVICE MANAGEMENT READY!"
echo "==========================="
echo ""
echo "üìã Available Commands:"
echo "   ~/workshop_services/scripts/service_monitor.sh start    # Start monitoring"
echo "   ~/workshop_services/scripts/service_monitor.sh status   # Check status"
echo "   ~/workshop_services/scripts/service_monitor.sh logs     # View logs"
echo ""

# Interactive menu
while true; do
    echo ""
    echo "üéõÔ∏è SERVICE CONTROL CENTER MENU"
    echo "=============================="
    echo "1) Check all services status"
    echo "2) Manage individual services"
    echo "3) Start service monitoring"
    echo "4) View monitoring logs"
    echo "5) Exit"
    echo ""
    
    read -p "Choose option (1-5): " main_choice
    
    case $main_choice in
        1)
            check_all_services
            ;;
        2)
            manage_services
            ;;
        3)
            echo "üöÄ Starting service monitoring in background..."
            nohup ~/workshop_services/scripts/service_monitor.sh start > /dev/null 2>&1 &
            echo "‚úÖ Monitor started. Check status with: ~/workshop_services/scripts/service_monitor.sh status"
            ;;
        4)
            echo "üìã Recent monitoring logs:"
            tail -20 ~/workshop_services/logs/monitor.log 2>/dev/null || echo "No logs found"
            ;;
        5)
            echo "üëã Exiting Service Control Center"
            break
            ;;
        *)
            echo "‚ùå Invalid choice"
            ;;
    esac
    
    read -p "Press Enter to continue..."
done
